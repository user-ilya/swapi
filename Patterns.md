// Использование функций 
 - Функции, которые мы передаем компоненту могут быть не только обработчиками событий 
 - Функция, может инкапсулировать получение данных (тогда компонент становится независимым от источника данных)

Render-Функция
В компонент передается функция, которая рендерит часть компонента. Такая функция обычно возвращает строку или react-элемент <Card renderBody = {() => {<span>hello</span>}}>

// Свойства-элементы 
В качестве значения свойства можно передавать React элемент: <Card title = {<h1>Hello</h1>} /> или элементы, которые умеют выбирать, что рендерить в зависимости от условия (загрузка, ошибка и тд).

// Children
Компоненту можно передавать одно из свойств, поместив его в тело элемента, а также оно поддерживает любые типы данных. Доступно через props.children.
Функция React.Children.map() - упрощает обработку props.children
Child элементы можно заменять, оборачивать в другие компоненты или скрывать(если вернуть null).


// Клонирование элементов 
React элементы нельзя изменять!
но можно создавать модифицированные копии с помощью React.cloneElement() - элементам можно добавлять новые свойства.

// Компоненты высшего порядка - функция, которая создает компоненты и оборачивает существующие компоненты.
const hoc = (Wrapper) => {
    return class extends Component {
        render () {
            return (
                <Wrapper {...this.props}>
            )
        }
    }
}
const MyWrapperComponent = hoc(ItemList)

// Контекст 
Контекст нужен для того, чтобы решать проблему "глобальных" данных. Вместо того, чтобы передвать props через все слои приложения, данные можно передавать через контекст. 
С помощью контекста мы сможем сделать так, чтобы компоненты не создавали объекты сервиса, а получили его.
const {Provider, Consumer} = React.createService(//можно задать начальный контекст)

// компонент высшего порядка и context api 
Обязанность получать данные из контекста можно вынести в компонент высшего порядка: 
const withValueFromContext = (Wrapper) => {
    return (
        <Consumer>
           {
                () => <Wrapper value = {value} />
           }
        </Consumer>
    ) 
}

// Обновления контекста 
Значение в контексте можно обновлять, как любое другое свойство компонента. Компоненты должны поддерживать изменения нужных свойств. componentDidUpdate() - функция в которой можно проверить, какие свойства изменились 

// Функция compose() и reduceRight()
const res = arr.reduceRight((prevResult, value) => {
    return prevResult + value
}, value(по умолчанию(Будет записано в самом начале))) -- Проход по массиву справа налево 

const compose = (...funcs) => (Component) => {
    return funcs.reduceRight((prevResult, f(одна из функций))=> f)(prevResult), Component)
}

// defaultProps (значения свойств по умолчанию для компонента)
// propsTypes (позволяет проверить значение свойств (props), которые получает компонент)
const Comp = ({name}) => {
    return (
        <p>{name}</p>
    )
}
Comp.propTypes = {
    name: (props, propName, componentName) => {...}
}
Проверка срабатывает после defaultProps.
Функция-валидатор возвращает null или объект Error.
ComponentName.propTypes = {
    count: (props, propsName, componentName) => {
        const value = props[propsName];
        if (typeof value === 'number' && !isNaN(value)) {
            return null
        }
        return new TypeError(`${componentName} ${propsName} must be number !`)
    }
}

// Библиотека props-types - это набор стандартных функций-валидаторов. Есть и другие библиотеки, с другими валидаторами, к примеру: airbnb-prop-types
